/**
 * twitter-api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2019-11-21T00:51:46Z
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { AuthResponse } from '../model/authResponse';
import { Empty } from '../model/empty';
import { FeedStatusesResponse } from '../model/feedStatusesResponse';
import { HashtagStatusesResponse } from '../model/hashtagStatusesResponse';
import { IsFollowingResponse } from '../model/isFollowingResponse';
import { PostStatusRequest } from '../model/postStatusRequest';
import { ProfileResponse } from '../model/profileResponse';
import { Response } from '../model/response';
import { SignupRequest } from '../model/signupRequest';
import { StatusResponse } from '../model/statusResponse';
import { StoryStatusesResponse } from '../model/storyStatusesResponse';
import { UpdateProfileRequest } from '../model/updateProfileRequest';
import { UserResponse } from '../model/userResponse';
import { UsersResponse } from '../model/usersResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'https://hpbubuiaz6.execute-api.us-east-1.amazonaws.com/prod';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     *
     *
     * @param followHandle
     * @param userHandle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public followUserHandleFollowHandleGet(followHandle: string, userHandle: string, observe?: 'body', reportProgress?: boolean): Observable<IsFollowingResponse>;
    public followUserHandleFollowHandleGet(followHandle: string, userHandle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IsFollowingResponse>>;
    public followUserHandleFollowHandleGet(followHandle: string, userHandle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IsFollowingResponse>>;
    public followUserHandleFollowHandleGet(followHandle: string, userHandle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (followHandle === null || followHandle === undefined) {
            throw new Error('Required parameter followHandle was null or undefined when calling followUserHandleFollowHandleGet.');
        }

        if (userHandle === null || userHandle === undefined) {
            throw new Error('Required parameter userHandle was null or undefined when calling followUserHandleFollowHandleGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<IsFollowingResponse>(`${this.basePath}/follow/${encodeURIComponent(String(userHandle))}/${encodeURIComponent(String(followHandle))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param followHandle
     * @param userHandle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public followUserHandleFollowHandlePost(followHandle: string, userHandle: string, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public followUserHandleFollowHandlePost(followHandle: string, userHandle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public followUserHandleFollowHandlePost(followHandle: string, userHandle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public followUserHandleFollowHandlePost(followHandle: string, userHandle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (followHandle === null || followHandle === undefined) {
            throw new Error('Required parameter followHandle was null or undefined when calling followUserHandleFollowHandlePost.');
        }

        if (userHandle === null || userHandle === undefined) {
            throw new Error('Required parameter userHandle was null or undefined when calling followUserHandleFollowHandlePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Response>(`${this.basePath}/follow/${encodeURIComponent(String(userHandle))}/${encodeURIComponent(String(followHandle))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param followHandle
     * @param userHandle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public followUserHandleFollowHandleUnfollowPost(followHandle: string, userHandle: string, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public followUserHandleFollowHandleUnfollowPost(followHandle: string, userHandle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public followUserHandleFollowHandleUnfollowPost(followHandle: string, userHandle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public followUserHandleFollowHandleUnfollowPost(followHandle: string, userHandle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (followHandle === null || followHandle === undefined) {
            throw new Error('Required parameter followHandle was null or undefined when calling followUserHandleFollowHandleUnfollowPost.');
        }

        if (userHandle === null || userHandle === undefined) {
            throw new Error('Required parameter userHandle was null or undefined when calling followUserHandleFollowHandleUnfollowPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Response>(`${this.basePath}/follow/${encodeURIComponent(String(userHandle))}/${encodeURIComponent(String(followHandle))}/unfollow`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param pageSize
     * @param hashtag
     * @param lastHashtag
     * @param lastTimestamp
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statusesHashtagHashtagGet(pageSize: string, hashtag: string, lastHashtag?: string, lastTimestamp?: string, observe?: 'body', reportProgress?: boolean): Observable<HashtagStatusesResponse>;
    public statusesHashtagHashtagGet(pageSize: string, hashtag: string, lastHashtag?: string, lastTimestamp?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<HashtagStatusesResponse>>;
    public statusesHashtagHashtagGet(pageSize: string, hashtag: string, lastHashtag?: string, lastTimestamp?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<HashtagStatusesResponse>>;
    public statusesHashtagHashtagGet(pageSize: string, hashtag: string, lastHashtag?: string, lastTimestamp?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling statusesHashtagHashtagGet.');
        }

        if (hashtag === null || hashtag === undefined) {
            throw new Error('Required parameter hashtag was null or undefined when calling statusesHashtagHashtagGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastHashtag !== undefined && lastHashtag !== null) {
            queryParameters = queryParameters.set('lastHashtag', <any>lastHashtag);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (lastTimestamp !== undefined && lastTimestamp !== null) {
            queryParameters = queryParameters.set('lastTimestamp', <any>lastTimestamp);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<HashtagStatusesResponse>(`${this.basePath}/statuses/hashtag/${encodeURIComponent(String(hashtag))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statusesPostOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public statusesPostOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public statusesPostOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public statusesPostOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/statuses/post`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param postStatusRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statusesPostPost(postStatusRequest: PostStatusRequest, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public statusesPostPost(postStatusRequest: PostStatusRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public statusesPostPost(postStatusRequest: PostStatusRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public statusesPostPost(postStatusRequest: PostStatusRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (postStatusRequest === null || postStatusRequest === undefined) {
            throw new Error('Required parameter postStatusRequest was null or undefined when calling statusesPostPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Response>(`${this.basePath}/statuses/post`,
            postStatusRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param statusId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public statusesStatusStatusIdGet(statusId: string, observe?: 'body', reportProgress?: boolean): Observable<StatusResponse>;
    public statusesStatusStatusIdGet(statusId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StatusResponse>>;
    public statusesStatusStatusIdGet(statusId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StatusResponse>>;
    public statusesStatusStatusIdGet(statusId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (statusId === null || statusId === undefined) {
            throw new Error('Required parameter statusId was null or undefined when calling statusesStatusStatusIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<StatusResponse>(`${this.basePath}/statuses/status/${encodeURIComponent(String(statusId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param pageSize
     * @param handle
     * @param lastHandle
     * @param lastTimestamp
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleFeedGet(pageSize: string, handle: string, lastHandle?: string, lastTimestamp?: string, observe?: 'body', reportProgress?: boolean): Observable<FeedStatusesResponse>;
    public usersHandleFeedGet(pageSize: string, handle: string, lastHandle?: string, lastTimestamp?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeedStatusesResponse>>;
    public usersHandleFeedGet(pageSize: string, handle: string, lastHandle?: string, lastTimestamp?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeedStatusesResponse>>;
    public usersHandleFeedGet(pageSize: string, handle: string, lastHandle?: string, lastTimestamp?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling usersHandleFeedGet.');
        }

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleFeedGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lastHandle !== undefined && lastHandle !== null) {
            queryParameters = queryParameters.set('lastHandle', <any>lastHandle);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (lastTimestamp !== undefined && lastTimestamp !== null) {
            queryParameters = queryParameters.set('lastTimestamp', <any>lastTimestamp);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<FeedStatusesResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/feed`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param pageSize
     * @param handle
     * @param userHandle
     * @param followHandle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleFollowersGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'body', reportProgress?: boolean): Observable<UsersResponse>;
    public usersHandleFollowersGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsersResponse>>;
    public usersHandleFollowersGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsersResponse>>;
    public usersHandleFollowersGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling usersHandleFollowersGet.');
        }

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleFollowersGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (userHandle !== undefined && userHandle !== null) {
            queryParameters = queryParameters.set('userHandle', <any>userHandle);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (followHandle !== undefined && followHandle !== null) {
            queryParameters = queryParameters.set('followHandle', <any>followHandle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<UsersResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/followers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param pageSize
     * @param handle
     * @param userHandle
     * @param followHandle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleFollowingGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'body', reportProgress?: boolean): Observable<UsersResponse>;
    public usersHandleFollowingGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsersResponse>>;
    public usersHandleFollowingGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsersResponse>>;
    public usersHandleFollowingGet(pageSize: string, handle: string, userHandle?: string, followHandle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling usersHandleFollowingGet.');
        }

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleFollowingGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (userHandle !== undefined && userHandle !== null) {
            queryParameters = queryParameters.set('userHandle', <any>userHandle);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (followHandle !== undefined && followHandle !== null) {
            queryParameters = queryParameters.set('followHandle', <any>followHandle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<UsersResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/following`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleGet(handle: string, observe?: 'body', reportProgress?: boolean): Observable<UserResponse>;
    public usersHandleGet(handle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserResponse>>;
    public usersHandleGet(handle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserResponse>>;
    public usersHandleGet(handle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<UserResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleLoginGet(handle: string, observe?: 'body', reportProgress?: boolean): Observable<AuthResponse>;
    public usersHandleLoginGet(handle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AuthResponse>>;
    public usersHandleLoginGet(handle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AuthResponse>>;
    public usersHandleLoginGet(handle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleLoginGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<AuthResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/login`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleLoginOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public usersHandleLoginOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public usersHandleLoginOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public usersHandleLoginOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/users/${encodeURIComponent(String('handle'))}/login`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleLogoutOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public usersHandleLogoutOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public usersHandleLogoutOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public usersHandleLogoutOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/users/${encodeURIComponent(String('handle'))}/logout`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleLogoutPost(handle: string, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public usersHandleLogoutPost(handle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public usersHandleLogoutPost(handle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public usersHandleLogoutPost(handle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleLogoutPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<Response>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/logout`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleProfileGet(handle: string, observe?: 'body', reportProgress?: boolean): Observable<ProfileResponse>;
    public usersHandleProfileGet(handle: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ProfileResponse>>;
    public usersHandleProfileGet(handle: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ProfileResponse>>;
    public usersHandleProfileGet(handle: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleProfileGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ProfileResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/profile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleProfileOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public usersHandleProfileOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public usersHandleProfileOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public usersHandleProfileOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/users/${encodeURIComponent(String('handle'))}/profile`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param updateProfileRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleProfilePost(handle: string, updateProfileRequest: UpdateProfileRequest, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public usersHandleProfilePost(handle: string, updateProfileRequest: UpdateProfileRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public usersHandleProfilePost(handle: string, updateProfileRequest: UpdateProfileRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public usersHandleProfilePost(handle: string, updateProfileRequest: UpdateProfileRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleProfilePost.');
        }

        if (updateProfileRequest === null || updateProfileRequest === undefined) {
            throw new Error('Required parameter updateProfileRequest was null or undefined when calling usersHandleProfilePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Response>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/profile`,
            updateProfileRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleSignupOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public usersHandleSignupOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public usersHandleSignupOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public usersHandleSignupOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/users/${encodeURIComponent(String('handle'))}/signup`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param handle
     * @param signupRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleSignupPost(handle: string, signupRequest: SignupRequest, observe?: 'body', reportProgress?: boolean): Observable<Response>;
    public usersHandleSignupPost(handle: string, signupRequest: SignupRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Response>>;
    public usersHandleSignupPost(handle: string, signupRequest: SignupRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Response>>;
    public usersHandleSignupPost(handle: string, signupRequest: SignupRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleSignupPost.');
        }

        if (signupRequest === null || signupRequest === undefined) {
            throw new Error('Required parameter signupRequest was null or undefined when calling usersHandleSignupPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Response>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/signup`,
            signupRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param pageSize
     * @param handle
     * @param ownerHandle
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleStoryGet(pageSize: string, handle: string, ownerHandle?: string, id?: string, observe?: 'body', reportProgress?: boolean): Observable<StoryStatusesResponse>;
    public usersHandleStoryGet(pageSize: string, handle: string, ownerHandle?: string, id?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StoryStatusesResponse>>;
    public usersHandleStoryGet(pageSize: string, handle: string, ownerHandle?: string, id?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StoryStatusesResponse>>;
    public usersHandleStoryGet(pageSize: string, handle: string, ownerHandle?: string, id?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling usersHandleStoryGet.');
        }

        if (handle === null || handle === undefined) {
            throw new Error('Required parameter handle was null or undefined when calling usersHandleStoryGet.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (ownerHandle !== undefined && ownerHandle !== null) {
            queryParameters = queryParameters.set('ownerHandle', <any>ownerHandle);
        }
        if (id !== undefined && id !== null) {
            queryParameters = queryParameters.set('id', <any>id);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<StoryStatusesResponse>(`${this.basePath}/users/${encodeURIComponent(String(handle))}/story`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     *
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersHandleStoryOptions(observe?: 'body', reportProgress?: boolean): Observable<Empty>;
    public usersHandleStoryOptions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Empty>>;
    public usersHandleStoryOptions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Empty>>;
    public usersHandleStoryOptions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.options<Empty>(`${this.basePath}/users/${encodeURIComponent(String('handle'))}/story`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
